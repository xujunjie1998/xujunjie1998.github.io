<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一章 网络概述</title>
    <url>/2021/08/05/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="计算机网络第一章（概述）"><a href="#计算机网络第一章（概述）" class="headerlink" title="计算机网络第一章（概述）"></a>计算机网络第一章（概述）</h1><hr>
<h2 id="网络、互联网（互连网）和因特网"><a href="#网络、互联网（互连网）和因特网" class="headerlink" title="网络、互联网（互连网）和因特网"></a>网络、互联网（互连网）和因特网</h2><p><strong>网络</strong>：网络（Network）由若干<strong>结点（Node）</strong>和连接这些结点的<strong>链路（Link）</strong>组成。<br><strong>互连网</strong>（互联网）：多个网络通过路由器互连起来，就构成了一个覆盖范围更大的网络，即互连网（互联网），又称为“网络的网络（Network of Networks）”。<br><strong>因特网</strong>：因特网（Internet）是世界上最大的互连网络。<br><img src="/2021/08/05/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/myblog\hexo\文章图片\01_\00_网络.PNG" alt></p>
<p><strong>ISP</strong>: 网络服务提供商（Internet Service Provider)。</p>
<hr>
<h2 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h2><p>边缘部分：<br>核心部分：</p>
<hr>
<h2 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h2><p>电路交换：</p>
<blockquote>
<ul>
<li>通信前需要建立连接</li>
<li>释放连接之前会一直占用通信资源</li>
<li>通信后需要释放连接</li>
<li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点</li>
<li>由于计算机数据是突发式地出现在传输线路上的，当使用电路交换来传送计算机数据时，其线路的传输效率往往很低，所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</li>
</ul>
</blockquote>
<p>分组交换：</p>
<blockquote>
<ul>
<li>无需建立连接，在发送时将数据分块，加上由必要控制信息组成的<strong>首部</strong>（包含了源地址和目的地址）发送</li>
<li>分组由路由器进行转发</li>
</ul>
</blockquote>
<p>报文交换：</p>
<blockquote>
<ul>
<li>无需建立连接，报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</li>
</ul>
</blockquote>
<hr>
<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><p>速率：比特率或数据率<br>带宽：表示网络通信线路所能传输数据的能力（可以理解为最高速率）<br>吞吐量：不会超过带宽<br>时延：发送时延、传播时延·、处理时延（包含排队时延）<br>时延带宽积：</p>
<p><img src="https://s1.imagehub.cc/images/2021/08/06/06_6579e7121209e81b.png" alt></p>
<p>往返时间(RTT)：<br>利用率：<br>丢包率：</p>
<hr>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="/2021/08/05/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/myblog\hexo\source\_posts\01_计算机网络概述.assets\image-20210808115204636.png" alt="image-20210808115204636"></p>
<h3 id="常见的网络体系结构"><a href="#常见的网络体系结构" class="headerlink" title="常见的网络体系结构"></a>常见的网络体系结构</h3><h3 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h3><h3 id="计算机网络通信过程"><a href="#计算机网络通信过程" class="headerlink" title="计算机网络通信过程"></a>计算机网络通信过程</h3><h3 id="计算机网络专用术语"><a href="#计算机网络专用术语" class="headerlink" title="计算机网络专用术语"></a>计算机网络专用术语</h3><hr>
]]></content>
  </entry>
  <entry>
    <title>02_物理层</title>
    <url>/2021/08/08/02_%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="2、计算机网络第二章（物理层）"><a href="#2、计算机网络第二章（物理层）" class="headerlink" title="2、计算机网络第二章（物理层）"></a>2、计算机网络第二章（物理层）</h1><hr>
<h2 id="2-1、基本概念"><a href="#2-1、基本概念" class="headerlink" title="2.1、基本概念"></a>2.1、基本概念</h2><hr>
<h2 id="2-2、传输媒体"><a href="#2-2、传输媒体" class="headerlink" title="2.2、传输媒体"></a>2.2、传输媒体</h2><ul>
<li>导引型传输媒体</li>
<li>非导引型传输媒体</li>
</ul>
<hr>
<h2 id="2-3、传输方式"><a href="#2-3、传输方式" class="headerlink" title="2.3、传输方式"></a>2.3、传输方式</h2><ul>
<li>串行传输与并行传输</li>
<li>同步传输与异步传输</li>
<li>单向通信、双向交替通信（半双工）和双向同时通信（全双工）</li>
</ul>
<hr>
<h2 id="2-4、编码与调制"><a href="#2-4、编码与调制" class="headerlink" title="2.4、编码与调制"></a>2.4、编码与调制</h2><ul>
<li>传输媒体与信道</li>
<li>常用编码</li>
<li>调制</li>
<li>码元</li>
</ul>
<hr>
<h2 id="2-5、信道的极限容量"><a href="#2-5、信道的极限容量" class="headerlink" title="2.5、信道的极限容量"></a>2.5、信道的极限容量</h2><ul>
<li>奈斯特公式</li>
<li>香农公式</li>
</ul>
<hr>
<h2 id="2-6、信道复用技术"><a href="#2-6、信道复用技术" class="headerlink" title="2.6、信道复用技术"></a>2.6、信道复用技术</h2><ul>
<li>频分复用</li>
<li>时分复用</li>
<li>统计时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
<hr>
]]></content>
  </entry>
  <entry>
    <title>常用排序算法之快速排序（c++实现）</title>
    <url>/2021/08/12/03-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88c-%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>[TOC]</p>
<hr>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>​        快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br>​        也就是先确定一个基准元素，每次都将基准元素排到正确的位置，保证它左边的元素都小于或等于它，它右边的元素都大于或等于它，然后对其左边和右边的全部元素分别再快速排序。</p>
<hr>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol>
<li>在数组中选择一个基准数（通常为数组第一个）；</li>
<li>将数组中小于基准数的数据移动到基准数左边，大于基准数的移动到右边；</li>
<li>对于基准数左右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序</li>
</ol>
<p>以下是一次快速排序的例子：<br><img src="/2021/08/12/03-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88c-%E5%AE%9E%E7%8E%B0%EF%BC%89/image-20210812170519656.png" alt="image-20210812170519656"></p>
<hr>
<h2 id="完整c-代码"><a href="#完整c-代码" class="headerlink" title="完整c++代码"></a>完整c++代码</h2><blockquote>
<p>3.1、设置两个变量 first、last，排序开始时：first=0，last=size-1。<br>3.2、整个数组找基准正确位置，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面</p>
<ol>
<li>默认数组的第一个数为基准数据，赋值给key，即key=array[first]。</li>
<li>因为默认数组的第一个数为基准，所以从后面开始向前搜索（last），找到第一个小于key的array[last]，就将 array[last] 赋给 array[first]，即 array[first] = array[last]。（循环条件是 first &lt; last &amp;&amp; array[last] &gt;= temp）</li>
<li>此时从前面开始向后搜索（first），找到第一个大于key的array[first]，就将 array[first] 赋给 array[last]，即 array[last] = array[first]。（循环条件是first &lt; last &amp;&amp; array[first] &lt;= temp）</li>
<li>循环 2-3 步骤，直到 first=last，该位置就是基准位置。把基准数据赋给当前位置。</li>
</ol>
<p>3.3、第一趟找到的基准位置，作为下一趟的分界点。<br>3.4、递归调用（recursive）分界点前和分界点后的子数组排序，重复1、2、3、4的步骤。<br>3.5、最终就会得到排序好的数组。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void display(vector&lt;int&gt; &amp;array, int size) &#123;</span><br><span class="line">	for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">		cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速排序</span><br><span class="line">void quick_sort(vector&lt;int&gt; &amp;array, int start, int end)&#123;</span><br><span class="line">	if (start &gt;= end) return;//如果子集里只有一个元素则不用排序</span><br><span class="line"></span><br><span class="line">	//将大于基准元素的值移动至右边，小于基准元素的值移动至左边</span><br><span class="line">	int first = start, last = end, temp = array[first];</span><br><span class="line">	while (first &lt; last)&#123;</span><br><span class="line">		//一直将last向左移动至array[last] &lt; temp或first &gt;= last</span><br><span class="line">		while (first &lt; last &amp;&amp; array[last] &gt;= temp)&#123;</span><br><span class="line">			--last;</span><br><span class="line">		&#125;</span><br><span class="line">		array[first] = array[last];</span><br><span class="line"></span><br><span class="line">		//一直将first向右移动至array[first] &gt; temp或first &gt;= last</span><br><span class="line">		while (first &lt; last &amp;&amp; array[first] &lt;= temp)&#123;</span><br><span class="line">			++first;</span><br><span class="line">		&#125;</span><br><span class="line">		array[last] = array[first];</span><br><span class="line">	&#125;</span><br><span class="line">	array[first] = temp;</span><br><span class="line"></span><br><span class="line">	quick_sort(array, start, first - 1);//将基准元素的左子集进行排序</span><br><span class="line">	quick_sort(array, first + 1, end);//将基准元素的右子集进行排序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	 int size      = 20;</span><br><span class="line">	 vector&lt;int&gt; array(20, 0);                 // 数组初始化</span><br><span class="line">	 for (int i = 0; i &lt; 5; i++) &#123;       // 数组个数</span><br><span class="line">	     for (int j = 0; j &lt; size; j++) &#123; // 数组大小</span><br><span class="line">	         array[j] = rand() % 100;    // 随机生成数大小 0~99</span><br><span class="line">	     &#125;</span><br><span class="line">	     cout &lt;&lt; &quot;原来的数组&quot; &lt;&lt; endl;</span><br><span class="line">	     display(array, size);</span><br><span class="line">	     quick_sort(array, 0, size - 1);</span><br><span class="line">		 cout &lt;&lt; &quot;排序后的数组&quot; &lt;&lt; endl;</span><br><span class="line">	     display(array, size);</span><br><span class="line">		 cout &lt;&lt; endl;</span><br><span class="line">	 &#125;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>时间复杂度：</p>
<script type="math/tex; mode=display">
最好：O ( n l o g _2 n )</script><script type="math/tex; mode=display">
最坏：O ( n^2 )</script><script type="math/tex; mode=display">
平均：O ( n l o g_2 n )</script><p>空间复杂度：</p>
<script type="math/tex; mode=display">
空间复杂度：O ( n l o g_2 n )</script><p>稳定性：不稳定</p>
]]></content>
  </entry>
  <entry>
    <title>04_常用排序算法之归并排序（c++实现）</title>
    <url>/2021/08/18/04-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="常用排序算法之归并排序（c-实现）"><a href="#常用排序算法之归并排序（c-实现）" class="headerlink" title="常用排序算法之归并排序（c++实现）"></a>常用排序算法之归并排序（c++实现）</h1><hr>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>​        归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的<strong>分治</strong>（divide-and-conquer）策略（分治法将问题<strong>分</strong>(divide)成一些小的问题然后递归求解，而<strong>治(conquer)</strong>的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。<br>​        归并算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p>
<hr>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>归并排序是用分治思想，可以递归求解，分治模式在每一层递归上有三个步骤：</p>
<blockquote>
<ul>
<li><strong>分解（Divide）</strong>：将n个元素分成个含n/2个元素的子序列。</li>
<li><strong>解决（Conquer）</strong>：用归并排序法对两个子序列分别排序（递归）。</li>
<li><strong>合并（Combine）</strong>：将两个已排好序的子序列进行归并。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/04-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1258817-20190326201207440-689679432.gif" alt="1258817-20190326201207440-689679432"></p>
<p><img src="/2021/08/18/04-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20210820093244466.png" alt="image-20210820093244466"></p>
<hr>
<h2 id="完整c-代码"><a href="#完整c-代码" class="headerlink" title="完整c++代码"></a>完整c++代码</h2><blockquote>
<p>(1)判断待排序数组是否只剩一个元素，若是则返回；若不是则将数组一分为二；<br>(2)将分好的两个子序列分别进行归并排序；<br>(3)将两个已经排好序的子序列进行有序合并。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;array, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">		cout &lt;&lt; array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, vector&lt;<span class="keyword">int</span>&gt; &amp;temp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;<span class="comment">//将待排序数组分为左右两个子序列</span></span><br><span class="line">	<span class="built_in">merge_sort</span>(nums, l, m, temp);<span class="comment">//对左边的子序列进行归并排序</span></span><br><span class="line">	<span class="built_in">merge_sort</span>(nums, m+<span class="number">1</span>, r, temp);<span class="comment">//对右边的子序列进行归并排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> q = l, p = m + <span class="number">1</span>, i = l;</span><br><span class="line">	<span class="keyword">while</span> (q &lt;= m || p &lt;= r)&#123;<span class="comment">//对左右两个已排好序的子序列进行有序合并</span></span><br><span class="line">		<span class="keyword">if</span> (q &gt; m || (p &lt;= r &amp;&amp; nums[p] &lt; nums[q]))&#123;</span><br><span class="line">			temp[i++] = nums[p++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			temp[i++] = nums[q++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = l; i &lt;= r; i++)&#123;</span><br><span class="line">		nums[i] = temp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; array = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;                 <span class="comment">// 数组初始化</span></span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;原来的数组&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">display</span>(array, size);</span><br><span class="line">	<span class="built_in">merge_sort</span>(array, <span class="number">0</span>, size - <span class="number">1</span>, temp);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;排序后的数组&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">display</span>(array, size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><blockquote>
<p>平均时间复杂度：O(nlogn)<br>最佳时间复杂度：O(n)<br>最差时间复杂度：O(nlogn)<br>空间复杂度：O(n)<br>稳定性：稳定</p>
</blockquote>
<p>​        不管待排序数组有序还是无序都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都为：O( nlogn )。<br>​        归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n + logn；所以空间复杂度为: O(n)。<br>​        归并排序算法中，归并最后到底都是相邻元素之间的比较交换，并不会发生相同元素的相对位置发生变化，故是稳定性算法。</p>
]]></content>
  </entry>
</search>
